from gmpy2 import isqrt, square, invert, powmod

# Problem 1
N = 179769313486231590772930519078902473361797697894230657273430081157732675805505620686985379449212982959585501387537164015710139858647833778606925583497541085196591615128057575940752635007475935288710823649949940771895617054361149474865046711015101563940680527540071584560878577663743040086340742855278549092581
sqrt_n  = isqrt(N)
A = sqrt_n + 1 #since A is an integer, rounding square root of N up to the closest integer reveals the value of A
x = isqrt(square(A) - N)
p = A - x
q = A + x
print min(p, q)

# Problem 2
N = 648455842808071669662824265346772278726343720706976263060439070378797308618081116462714015276061417569195587321840254520655424906719892428844841839353281972988531310511738648965962582821502504990264452100885281673303711142296421027840289307657458645233683357077834689715838646088239640236866252211790085787877
sqrt_n = isqrt(N)
inc = 1
while True:
    A = sqrt_n + inc # try scanning for A from square root of N upwards, until you succeed in factoring N
    x = isqrt(square(A) - N)
    p = A - x
    q = A + x
    if p * q == N:
        print min(p, q)
        break
    else:
        inc += 1

# Problem 3
N = 720062263747350425279564435525583738338084451473999841826653057981916355690188337790423408664187663938485175264994017897083524079135686877441155132015188279331812309091996246361896836573643119174094961348524639707885238799396839230364676670221627018353299443241192173812729276147530748597302192751375739387929
# TODO

# Problem 4
cipher = 22096451867410381776306561134883418017410069787892831071731839143676135600120538004282329650473509424343946219751512256465839967942889460764542040581564748988013734864120452325229320176487916666402997509188729971690526083222067771600019329260870009579993724077458967773697817571267229951148662959627934791540
N = 179769313486231590772930519078902473361797697894230657273430081157732675805505620686985379449212982959585501387537164015710139858647833778606925583497541085196591615128057575940752635007475935288710823649949940771895617054361149474865046711015101563940680527540071584560878577663743040086340742855278549092581
sqrt_n  = isqrt(N)
A = sqrt_n + 1 #since A is an integer, rounding square root of N up to the closest integer reveals the value of A
x = isqrt(square(A) - N)
p = A - x
q = A + x
totient_n = N - p - q + 1 #totient(n) => totient(pq) => (p-1)(q-1) => pq - p - q + q => N - p - q + 1
e=65537
d= invert(e, totient_n) # Since d is relatively prime to totient(n), it has a multiplicativer inverse such that: d.e = 1 mod totient(n)
pkcs_encoded_text = hex(powmod(cipher, d , N))
hex_decoded_text = pkcs_encoded_text[pkcs_encoded_text.find('00') + 2:].decode('hex')
print hex_decoded_text







